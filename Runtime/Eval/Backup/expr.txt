import { Stmt, CallExpr, AssignmentExpr, BinaryExpr, Expr, Identifier, MemberExpr, NumericLiteral, ObjectLiteral, StringLiteral, FunctionDeclaration, SelectionStmtDeclaration, IterationStmt, OutputExpr, inputExpr, FileUse, CharString, UnaryExpr, ReturnStmt } from "../../Frontend/AST.js";
import Environment, { SetupGlobalScope } from "../Environment.js";
import { evaluate } from "../Interpreter.js";
import { primitiveValue, NativeFnValue, MemberExprVal, NumberVal, RuntimeVal, MK_NULL, ValueType,  ObjectVal, BooleanVal, FunctionValue, StringVal, CharVal, NullVal, SelectionStmt, MK_STRING, MK_BOOL, MK_NUMBER, endClosureVal } from "../Value.js";
import { Token, tokenize, Tokens } from "../../Frontend/Lexer.js";
import { eval_fn_declaration } from "./Statements.js";
import { UseFile,outputLog, errorLog, makeError } from "../../Main.js";

function eval_numeric_binary_expr(
  
  lhs: NumberVal,
  rhs: NumberVal,
  operator: string,
): NumberVal | StringVal | BooleanVal | NullVal {
  let resultType : "number" | "string" | "boolean";
  let result: number | string | boolean;
  if (operator == "+") {
    //console.log("Attempt at adding the numbers");
    result = lhs.value + rhs.value;
    resultType = "number";

  } else if (operator == "-") {
    result = lhs.value - rhs.value;
    resultType = "number";

  } else if (operator == "*") {
    result = lhs.value * rhs.value;
    resultType = "number";

  } else if (operator == "/") {
      if(rhs.value == 0){
        return makeError("Division by zero!");
      }
      else{
        result = lhs.value / rhs.value;
        resultType = "number";
      }

  } else if (operator == '^'){

    result = lhs.value ** rhs.value;
    resultType = "number";

  } else if (operator == "<"){
    result = lhs.value < rhs.value;
    resultType = "boolean";

  } else if (operator == ">"){
    result = lhs.value > rhs.value;
    resultType = "boolean";

  } else if (operator == ">=" || operator == "≥"){
    result = lhs.value >= rhs.value;
    resultType = "boolean";

  } else if (operator == "<=" || operator == "≤"){
    result = lhs.value <= rhs.value;
    resultType = "boolean";

  } else if (operator == "="){
    result = lhs.value == rhs.value;
    resultType = "boolean"
  
  } else if (operator == '<>'){
    result = lhs.value !== rhs.value;
    resultType = "boolean"

  } else {
    return makeError("Unrecognised binary operator!");
  }

  let numberkind : NumberVal["numberKind"];

  if(isint(result.toString())){
    numberkind = Tokens.Integer;
  }
  else{
    numberkind = Tokens.Real;
  }
  
  switch(resultType){
    case "number":
      return { value: result as number, type: "number", numberKind: numberkind };

    case "boolean":
      return {value: result as boolean, type: "boolean"} as BooleanVal;

    default:
      return makeError("Invalid result expression!");
  }
  
}

function concantate_exprs(exprs : Expr[], env : Environment) : StringVal {

  let combined : StringVal = MK_STRING("");


  console.log("Concatenating expressions: " + JSON.stringify(exprs));

  for(const expr of exprs){


    const test = evaluate(expr, env);
    
    let str = (convThisToStr(test)).value;

    if(test.type == "char" && str.startsWith("'") && str.endsWith("'")){

      str = str.slice(1,-1);

    }

    combined.value += str;


  }



  return combined;

}

let outputIndex = 0;
let outputInterval: number | undefined;

export function displayOutputMessages(messages: OutputExpr[], env: Environment) {
  outputIndex = 0;

  // Clear any previous interval
  if (outputInterval !== undefined) {
    clearInterval(outputInterval);
  }

  outputInterval = setInterval(() => {
    if (outputIndex >= messages.length) {
      // Stop the interval when all messages are processed
      clearInterval(outputInterval);
      outputInterval = undefined;
      return;
    }

    // Process one message per interval
    eval_output_expr(messages[outputIndex], env);
    outputIndex++;
  }, 50); // Adjust the interval (ms) as needed
}

export function eval_output_expr(
  output: OutputExpr,
  env: Environment
) {
  let messageComponent: StringVal = concantate_exprs(output.value, env);

  console.log("Message component: " + JSON.stringify(messageComponent));

  let message: string = convThisToStr(messageComponent).value;

  outputLog.push(message);

  access_console();

  console.log("Something tried to be outputted");

  return {
    type: "string",
    kind: "StringLiteral",
    value: messageComponent.value,
  } as StringVal;
}

function access_console() {
  const outLog = document.getElementById('Output');
  if (!outLog) {
    console.error("Output log element not found!");
    return;
  }

  let adapted = "";
  if (errorLog.length > 0) {
    outLog.style.setProperty("color", "red", "important");
    adapted = errorLog[0];
  } else {
    outLog.style.color = "white";

    for (const statement of outputLog) {
      const casted = String(JSON.stringify(statement));
      let trimmed =
        casted.startsWith("[") && casted.endsWith("]")
          ? casted.replace(/\\/g, "")
          : JSON.stringify(statement).slice(1, -1).replace(/\\/g, "");

      adapted += trimmed.replace(/"/g, "");
      adapted += "\n";
    }

    adapted = adapted.replace(/\\/g, "");
    adapted += "\n\n** Process exited **";
  }

  outLog.textContent = adapted;
  console.log("Output log text: " + outLog.textContent);
}




function eval_logic_binary_expr(
  lhs:BooleanVal | NullVal,
  rhs:BooleanVal,
  operator:string
){
  let result: boolean;

  if(operator == "AND"){
    result = lhs.value && rhs.value;
  }
  else if(operator == "OR"){



    result = lhs.value || rhs.value;
  }
  else if(operator == "NOT"){



    result = !rhs.value;
  }
  else if(operator == "<>"){
    result = lhs.value !== rhs.value;
  }
  else if(operator == "="){
    result = lhs.value == rhs.value;
  }

  else{
    return makeError("Cannot perform binary operation on boolean values!");
  }

  return {value:result, type:"boolean"} as BooleanVal;
}

function eval_string_binary_expr(
  lhs:StringVal,
  rhs:StringVal,
  operator:string,
){
  let resultType: "string" | "boolean";
  let result: string | boolean;

  if(operator == '='){
    
    console.log("DEBUGGER left string: " + JSON.stringify(lhs));
    console.log("DEBUGGER right string: " + JSON.stringify(rhs));

    result = lhs.value == rhs.value;
    resultType = "boolean";
  }
  else if(operator == '<>'){
    result = !(lhs.value == rhs.value);
    resultType = "boolean";
  }
  else if(operator == ','){

    let lVal = lhs.value;
    let rVal = rhs.value;

    if((lVal.startsWith('"') && lVal.endsWith('"')) || (lVal.startsWith("'") && lVal.endsWith("'"))){
      lVal = lVal.slice(1,-1);
    }

    if((rVal.startsWith('"') && rVal.endsWith('"')) || (rVal.startsWith("'") && rVal.endsWith("'"))){
      rVal = rVal.slice(1,-1);
    }

    result = lVal + rVal;
    resultType = "string";
  }
  else if(operator == '<'){
    result = lhs.value < rhs.value;
    resultType = "boolean";
  }
  else if(operator == '>'){
    result = lhs.value > rhs.value;
    resultType = "boolean";
  }
  else if(operator == '<='){
    result = lhs.value <= rhs.value;
    resultType = "boolean";
  }
  else if(operator == '>='){
    result = lhs.value >= rhs.value;
    resultType = "boolean";
  }
  else{
    return makeError(`Cannot use binary operator '${operator}' on operands of type ${lhs.type.toUpperCase()} and ${rhs.type.toUpperCase()}`);
  }


  if(resultType == "boolean"){
    return {value:result as boolean, type: "boolean"} as BooleanVal;
  }
  else if(resultType == "string"){
    return {value:result as string, type: "string", kind:"StringLiteral"} as StringVal;
  }
  else{
    return makeError("Invalid result expression!");
  }

}

export function isint(str) {
  const num = Number(str);
  return !isNaN(num) && Number.isInteger(num);
}


export function eval_fileUse_expr(fileUse : FileUse, env : Environment) : RuntimeVal{

  //throw new Error("Made it to evaluation");

  if(env.variables.has(fileUse.fileName)){
    if(fileUse.operation == "READ"){

          const raw = UseFile(fileUse.fileName, "READ") as string;
          let value : Expr;

          let badum : RuntimeVal;

          for(const expr of fileUse.assigne){
            const runtimeval = evaluate(expr, env);

            if(errorLog.length > 0){
              return null;
            }

            if(runtimeval.type == "Object"){

              let val = raw;

              if(val.startsWith('[') && val.endsWith(']')){
                val = val.slice(1,-1);
              }


              const obj = runtimeval as ObjectVal;

              const str = {
                type: "string",
                kind: "StringLiteral",
                value: val,
              } as StringVal;

              const newObj = assignStringToObj(str, obj);

              if(errorLog.length > 0){
                return MK_NULL();
              }

              const assignmentExpr = {
                kind: "AssignmentExpr",
                assigne: expr,
                value: [newObj],
              } as AssignmentExpr;

              badum = eval_assignment_expr(assignmentExpr, env);
            }
            else{
              value = automaticAssignement(runtimeval, raw);

              const assignmentExpr = {
                kind: "AssignmentExpr",
                assigne: expr,
                value: [value]
              } as AssignmentExpr;

              badum = eval_assignment_expr(assignmentExpr, env);
            }
          }

          return badum;


    }
    else{

      for(const expr of fileUse.assigne){
        let toAssign = evaluate(expr, env);

        if(errorLog.length > 0){
          return null;
        }

        toAssign = convThisToStr(toAssign) as StringVal;

        UseFile(fileUse.fileName, "WRITE", (toAssign as StringVal).value);
      }

      return MK_NULL();
    }
  }
  else{
    return makeError(`File ${fileUse.fileName} has not been opened in the current scope or does not exist!`);
  }


  
}

function extractBracketedGroups(input : string) : string[] {
    const regex = /\[[^\[\]]*?\]/g;
    return input.match(regex) || [];  //Thanks chatgpt :D
}

function assignStringToObj(getting : StringVal, expecting : ObjectVal) : ObjectLiteral {


  if(expecting.elements[0].type == "Object"){

    if(!(getting.value.startsWith('[') && getting.value.endsWith(']'))){
      makeError("Please wrap object literals in square brackets when assigning to 2d arrays");
    }

    const split = extractBracketedGroups(getting.value);

    let newObj = {
      kind: "ObjectLiteral",
      elements: [],
      start: {kind: "NumericLiteral", numberKind: Tokens.Integer, value: expecting.start},
      end : {kind: "NumericLiteral", numberKind: Tokens.Integer, value: expecting.end},
      innerStart: {kind: "NumericLiteral", numerKind: Tokens.Integer, value: (expecting.elements[0] as ObjectVal).start},
      innerEnd: {kind: "NumericLiteral", numerKind: Tokens.Integer, value: (expecting.elements[0] as ObjectVal).end},
      dataType: expecting.dataType,
      is2dArr: true,
      declaring: "Value",
    } as ObjectLiteral;

    if(split.length != expecting.elements.length){
      makeError(`Assigne array has length ${expecting.elements.length} but inputted array has length ${split.length}!`);
    }


    for(let i = 0; i < split.length; i++){

      let used = split[i].trim();

      if(used.startsWith('[') && used.endsWith(']')){
        used = used.slice(1,-1);
      }

      const newElm = assignStringToObj({type:"string", kind: "StringLiteral", value: used}, expecting.elements[i] as ObjectVal);

      newObj.elements.push(newElm);

    }

    return newObj;



  }
  else{
    let split : string[] = [];
    let newObj = {
      kind: "ObjectLiteral",
      elements: [],
      start: {kind: "NumericLiteral", numberKind: Tokens.Integer, value: expecting.start} as NumericLiteral,
      end: {kind: "NumericLiteral", numberKind: Tokens.Integer, value: expecting.end} as NumericLiteral,
      dataType: expecting.dataType,
      is2dArr:false,
      declaring: "Value",
    } as ObjectLiteral;
    newObj.elements = [];

    if(getting.value.includes(',')){
      split = getting.value.split(',');
    }
    else if(getting.value.includes(' ')){
      split = getting.value.split(' ');
    }
    else{
      split = getting.value.split('');
    }

    if(split.length != expecting.elements.length){
      makeError(`Assigne array has length ${expecting.elements.length} but inputted array has length ${split.length}!`);
    }

    
    switch(expecting.dataType){
      case Tokens.Char:

        

        for(const item of split){

          console.log("Item before trimming: " + item);

          const use = item.trim();

          console.log("Item after trimming: " + use);

          if(use.length > 1){
            makeError(`Item '${use}' of inputted array is not of type CHAR!`);
          }

          newObj.elements.push({kind: "CharString", text: use} as CharString);
        }

        break;

      case Tokens.Integer:
        for(const item of split){



          const use = item.trim();
          console.log("Item before trimming: " + use);
          if(!isint(Number(use))){
            makeError(`Item '${use}' of inputted array is not of type INTEGER!`);
          }

          newObj.elements.push({kind: "NumericLiteral", numberKind: Tokens.Integer, value: Number(use)} as NumericLiteral);
        }

        break;

      case Tokens.Real:
        for(const item of split){

          const use = item.trim();

          if(!isNumeric(use)){
            makeError(`Item '${use}' is not of type REAL!`);
          }

          newObj.elements.push({kind: "NumericLiteral", numberKind: Tokens.Real, value: Number(use)} as NumericLiteral);
        }

        break;

      case Tokens.Boolean:
        for(const item of split){

          const use = item.trim();

          if(use != "TRUE" && use != "FALSE"){
            makeError(`Item '${use}' is not of type BOOLEAN!`);
          }

          newObj.elements.push({kind: "Identifier", symbol: use} as Identifier);
        }

        break;

      default: 
        for(const item of split){
          newObj.elements.push({kind: "StringLiteral", text: item.trim()} as StringLiteral);
        }
    }



    return newObj;
  }



}

function inputCaster(getting : StringVal, expecting : RuntimeVal) : RuntimeVal{


  if(expecting.type == "string"){
    return convThisToStr(getting);
  }
  else if(expecting.type == "char"){
    if(getting.type == "string"){
      return {
        type: "char",
        value: (getting as StringVal).value,
      } as CharVal;
    }
    else{
      return makeError("Invalid assignment!");
    }
  }
  else if(expecting.type == "number"){
    const num = Number((getting as StringVal).value);

    return {
      type: "number",
      numberKind: (isint(num)) ? Tokens.Integer : Tokens.Real,
      value: num
    } as NumberVal;
  }
  else if(expecting.type == "boolean"){
    return {
      type: "boolean",
      value: (getting.value == "TRUE") ? true : false,
    } as BooleanVal;
  }
  else{
    return getting;
  }

}

function automaticAssignement(assigne : RuntimeVal, value : string) : Expr {

  let toUse = assigne;
  if(toUse.type == "MemberExprVal"){
    toUse = conv_memex_to_val(toUse as MemberExprVal);
  }

  if(toUse.type == "number" && isNumeric(value)){
    return {
      kind: "NumericLiteral",
      numberKind: (isint(Number(value)))
      ? Tokens.Integer
      : Tokens.Real,
      value: Number(value)
    } as NumericLiteral;
  }
  else if(toUse.type == "boolean" && (value == "TRUE" || value == "FALSE")){
    return {
      kind: "Identifier",
      symbol: value,

    } as Identifier;
  }
  else if(toUse.type == "char" && value.length == 1){
    return {
      kind: "CharString",
      text: value,
    } as CharString;
  }
  else{
    return {
      kind: "StringLiteral",
      text: value
    } as StringLiteral;
  }

}



export function eval_selectionStmt_expr(
  declaration: SelectionStmtDeclaration,
  env : Environment) : RuntimeVal {

    let result : RuntimeVal = MK_NULL();

    let scopes : Environment[] = [];
    
   
    console.log("Selection statement: " + JSON.stringify(declaration));



    console.log("Selection statement conditions: " + JSON.stringify(Array.from(declaration.body.keys())));
    for(const condition of declaration.body.keys()){


      //console.log("Result of condition: " + (evaluate(condition as Expr, env) as BooleanVal).value);


      if((evaluate(condition as Expr, env) as BooleanVal).value){
        console.log("Condition which has been evaluated as true: " + JSON.stringify(condition as Stmt));
        
        scopes.push(new Environment(env));
        for(const stmt of declaration.body.get(condition)){
          
          result = evaluate(stmt, scopes[scopes.length - 1]);
          
          console.log("Declaration return length: " + declaration.returns.length);

          if(declaration.returns.length > 0){
            
            const conditionArray = Array.from(declaration.body.keys());
            const returnIndex = conditionArray.indexOf(condition);

            result = evaluate(declaration.returns[returnIndex], scopes[scopes.length - 1]);
            
          }

          if(stmt.kind == "SelectionStmtDeclaration"){
            const temp = stmt as SelectionStmtDeclaration;
            const result = evaluate(temp, scopes[scopes.length - 1]);

            if(temp.returns.length > 0 && result.type != "end-closure" && result.type !== "null"){
              console.log("Attempting to return something from a case statement");
              return result;
            }
          }
          else if(stmt.kind == "IterationStmt"){
            const temp = stmt as IterationStmt;
            const result = evaluate(temp, scopes[scopes.length - 1]);
            if(temp.returnExpressions.length > 0 && result.type != "end-closure" && result.type !== "null"){
              return result;
            }
          }
          else if(stmt.kind == "ReturnStmt"){
            const result = evaluate((stmt as ReturnStmt), scopes[scopes.length - 1]);
            return result;
          }
        }

        console.log("Evaluated result: " + JSON.stringify(result));
        return result;
      }
      else{
        console.log(`Condition ${JSON.stringify(condition)} is false!`);
      }
    }

    console.log("What is result here: " + JSON.stringify(result));

    return result;

  }



export function conv_memex_to_val(memex : MemberExprVal)
{

  switch(memex.valueType){
    case "number":
      const num = memex.value as number;
      return {
        type: "number",
        numberKind: isint(num)
        ? Tokens.Integer
        : Tokens.Real,
        value: num,
      } as NumberVal;

    case "string":

      if((memex.value as string).length == 1){
        
        return {
          type: "char",
          value: memex.value as string,
        } as CharVal;
      }
      else{

        return {
          type: "string",
          kind: "StringLiteral",
          value: memex.value as string,
        } as StringVal;
      }

      

    case "boolean":
      return {
        type: "boolean",
        value: memex.value as boolean,
      } as BooleanVal;

    case "char":
      return {
        type: "char",
        value: memex.value as string,
      } as CharVal;

    case "Object":



      console.log("Memex as an object: " + JSON.stringify(memex));
      return {
        type: "Object",
        elements: memex.value as primitiveValue[],
        start: memex.parentObject.start,
        end: (memex.value as primitiveValue[]).length,
        dataType: assess_dataType_fromstring(String((memex.value as primitiveValue[])[0])),

      } as ObjectVal;




    default:

      return makeError("Invalid expression! Expression is of type " + memex.valueType);
  }

  
}




export function eval_input_expr(inpExpr : inputExpr, env : Environment) : RuntimeVal {

  //console.log("Record Var Y before input evaluation: " + JSON.stringify(env.lookupVar("Y")));

  let prmptComponent : RuntimeVal = concantate_exprs(inpExpr.promptMessage, env);

  if(prmptComponent.type == "MemberExprVal"){
    prmptComponent = conv_memex_to_val(prmptComponent as MemberExprVal);
  }

  let prmptText = String((prmptComponent as StringVal).value);

  if(prmptText.startsWith('"') && prmptText.endsWith('"')){
    prmptText = prmptText.slice(1,-1);
  }
  else if(prmptText.startsWith("'") && prmptText.endsWith("'")){
    prmptText = prmptText.slice(1,-1);
  }

  let val = prompt(prmptText);

  if(val === null){
    return makeError("Unexpected input cancellation lead to program termination!");
  }




  
  let badum : RuntimeVal;

  for(const expr of inpExpr.assigne){
    console.log("Evaluated assigne: " + JSON.stringify(evaluate(expr, env).type));
    if(!resolve_var(expr, env)){
      return null;
    }


    const evaluatedAssigne = evaluate(expr, env);

    

    if(evaluatedAssigne.type == "Object"){

      if(val.startsWith('[') && val.endsWith(']')){
        val = val.slice(1,-1);
      }


      const obj = evaluatedAssigne as ObjectVal;

      const str = {
        type: "string",
        kind: "StringLiteral",
        value: val,
      } as StringVal;

      const newObj = assignStringToObj(str, obj);

      if(errorLog.length > 0){
        return MK_NULL();
      }

      const assignmentExpr = {
        kind: "AssignmentExpr",
        assigne: expr,
        value: [newObj],
      } as AssignmentExpr;

      //console.log("Var Y after input evaluation: " + JSON.stringify(env.lookupVar("Y")));

      badum = eval_assignment_expr(assignmentExpr, env);

    }
    else{

      

      let aVal : Expr;

      const runTimeVal = evaluate(expr, env);
      aVal = automaticAssignement(runTimeVal, val);

      const assignMentExpr = {
        kind: "AssignmentExpr",
        assigne: expr,
        value: [aVal],
      } as AssignmentExpr;

      //onsole.log("Record Var Y during (1) input evaluation: " + JSON.stringify(env.lookupVar("Y")));

      //console.log("Record Y assignment expr: " + JSON.stringify(assignMentExpr));
      badum = eval_assignment_expr(assignMentExpr, env);

      //console.log("Record Var Y during (2) input evaluation: " + JSON.stringify(env.lookupVar("Y")));
    }

    
  }

  return badum;


  

}

function resolve_var(varExpr : Expr, env : Environment) : boolean{

  switch(varExpr.kind){
    case "Identifier":
      env.lookupVar((varExpr as Identifier).symbol);

      if(errorLog.length > 0){
        return false;
      }
      else{
        return true;
      }

    case "MemberExpr":
      env.lookupVar(((varExpr as MemberExpr).object as Identifier).symbol);

      if(errorLog.length > 0){
        return false;
      }
      else{
        return true;
      }

    case "AssignmentExpr":
      return resolve_var((varExpr as AssignmentExpr).assigne, env);
    
    default:
      return true;
  }

}

export function eval_return_stmt(node : ReturnStmt, env : Environment) : RuntimeVal {

  if(node.value.length == 1){
    return evaluate(node.value[0], env);
  }
  else{


    return concantate_exprs(node.value, env);

  }

}

export function eval_iteration_Stmt(iterStmt : IterationStmt, env : Environment) : RuntimeVal {

  let closures : Environment[] = [];


  console.log("Iteration statement return expressions: " + JSON.stringify(iterStmt.returnExpressions));

  const Limit = 2000;
  switch(iterStmt.iterationKind){
    case "count-controlled":
      


      const scope = new Environment(env);
      
      let startVal : RuntimeVal = evaluate(iterStmt.startVal, env);

      if(startVal.type == "MemberExprVal"){
        startVal = {
          type: "number",
          numberKind: Tokens.Integer,
          value: (startVal as MemberExprVal).value
        } as NumberVal;
      }
      else{
        startVal = {
          type: "number",
          numberKind: Tokens.Integer,
          value: (startVal as NumberVal).value,
        } as NumberVal
      }

      let endVal : RuntimeVal = evaluate(iterStmt.endVal, env);

      if(endVal.type == "MemberExprVal"){
        endVal = {
          type: "number",
          numberKind: Tokens.Integer,
          value: (endVal as MemberExprVal).value
        } as NumberVal;
      }
      else{
        endVal = {
          type: "number",
          numberKind: Tokens.Integer,
          value: (endVal as NumberVal).value,
        } as NumberVal
      }


      const varname = iterStmt.iterator.symbol;

      scope.declareVar(varname, startVal, false);


      let result : RuntimeVal = {type: "end-closure"} as endClosureVal;
      
      let step : RuntimeVal;

      

      if(iterStmt.step != undefined){
        step = evaluate(iterStmt.step, env);
        if(step.type == "MemberExprVal"){
          step = conv_memex_to_val((evaluate(iterStmt.step, env) as MemberExprVal));
        }
        else{
          step = {
            type: "number",
            numberKind: Tokens.Integer,
            value: (step as NumberVal).value,
          } as NumberVal;
        }

      }
      else{
        step = {
          type: "number",
          numberKind: Tokens.Integer,
          value: 1,
        } as NumberVal;
      }


      scope.assignVar(varname, {
        type: "number",
        numberKind: Tokens.Integer,
        value: (startVal as NumberVal).value,
      } as NumberVal)



      const strt = Number((startVal as NumberVal).value);
      const end = (endVal as NumberVal).value;
      let stp = (step as NumberVal).value;




      scope.assignVar(varname, {
        type: "number",
        numberKind: Tokens.Integer,
        value: strt,
      } as NumberVal)


      console.log("Iter details: " + strt, " ", end, " ", stp);


      if(stp < 0){



        for(let i = strt; i >= end; i+=stp){

          scope.assignVar(varname, {
            type: "number",
            numberKind: Tokens.Integer,
            value: i,
          } as NumberVal)


          closures = [new Environment(scope)];
          console.log("Iterstmt body: " + JSON.stringify(Array.from(iterStmt.body.entries())));

          for(const stmt of iterStmt.body){

            
            const currentEnv = closures[closures.length - 1];

            if(stmt.kind == "SelectionStmtDeclaration"){
              result = eval_selectionStmt_expr(stmt as SelectionStmtDeclaration, currentEnv);

              console.log("Resultee of selection statement: " + JSON.stringify(result));


              if(result){
                if(result.type !== "null" && (stmt as SelectionStmtDeclaration).returns.length > 0 && result.type != "end-closure"){


                  return result;
                }
              }
              
            }
            else if(stmt.kind == "IterationStmt"){

              result = eval_iteration_Stmt(stmt as IterationStmt, currentEnv);

              const temp = stmt as IterationStmt;

              if(result){
                if(result.type !== "null" && temp.returnExpressions.length > 0 && result.type != "end-closure"){
                  return result;
                }
              }
              
            }
            else if(stmt.kind == "ReturnStmt"){

              return eval_return_stmt(stmt as ReturnStmt, currentEnv);

            }
            else if(stmt.kind == "ErrorExpr" || errorLog.length > 0){
              return MK_NULL();
            }
            else{
              result = evaluate(stmt, currentEnv);

            }
          }


          const iterVal = (scope.lookupVar(varname) as NumberVal).value;
          
          /*if(iterVal < (endVal as NumberVal).value){
            return result;
          }*/
        
        }


        if(!result && strt < end){
          result = {type: "end-closure"} as endClosureVal;
        }

        return result;
      }
      else{
        console.log("Did you even get here?")

        for(let i = strt; i <= end; i+=stp){

          scope.assignVar(varname, MK_NUMBER(i, Tokens.Integer));

          


          closures = [new Environment(scope)];
          console.log("Iterstmt body: " + JSON.stringify(Array.from(iterStmt.body.entries())));

          for(const stmt of iterStmt.body){

            
            const currentEnv = closures[closures.length - 1];

            if(stmt.kind == "SelectionStmtDeclaration"){

              

              result = eval_selectionStmt_expr(stmt as SelectionStmtDeclaration, currentEnv);
              console.log("Resultee of selection statement: " + JSON.stringify(result));

              if(result){
                if(result.type !== "null" && (stmt as SelectionStmtDeclaration).returns.length > 0 && result.type != "end-closure"){

                  
                  return result;
                }
              }

              
            }
            else if(stmt.kind == "IterationStmt"){

              result = eval_iteration_Stmt(stmt as IterationStmt, currentEnv);

              const temp = stmt as IterationStmt;

              if(result){
                if(result.type !== "null" && temp.returnExpressions.length > 0 && result.type != "end-closure"){
                  return result;
                }
              }

              
            }
            else if(stmt.kind == "ReturnStmt"){
              console.count("Return called");
              return eval_return_stmt(stmt as ReturnStmt, currentEnv);

            }
            else if(stmt.kind == "ErrorExpr" || errorLog.length > 0){
              return MK_NULL();
            }
            else{
              result = evaluate(stmt, currentEnv);


            }
          }


          const iterVal = (scope.lookupVar(varname) as NumberVal).value;
          
          if(iterVal > (endVal as NumberVal).value){
            return result;
          }
        
        }

        if(!result && strt > end){
          result = {type: "end-closure"} as endClosureVal;
        }


        return result;
      }

      
      

    case "post-condition":
      
      const scpe = new Environment(env); 
      
      let condition : RuntimeVal = evaluate(iterStmt.iterationCondition, env);

      if(condition.type == "MemberExprVal"){
        condition = conv_memex_to_val(condition as MemberExprVal);
      }

      let res : RuntimeVal = {type: "end-closure"} as endClosureVal;
      
      let iterations = 0;

      closures = [new Environment(scpe)];
      const current = closures[closures.length - 1];

      for(const stmt of iterStmt.body){



        res = evaluate(stmt, current);


        if(stmt.kind == "ErrorExpr"){
          return MK_NULL();
        }
        if(stmt.kind == "SelectionStmtDeclaration" && (stmt as SelectionStmtDeclaration).returns){

          console.log("Supposed return expressions: " + JSON.stringify((stmt as SelectionStmtDeclaration).returns.length));

          if(res.type != "null" && (stmt as SelectionStmtDeclaration).returns.length > 0 && res.type != "end-closure"){
            
            console.log("Returning from an if statement :(")
            return res;
          }
          else{
            console.log("I don't know what condition this is but it certainly isn't the right one...");
          }
        }

        else if(res.type != "null" && stmt.kind == "IterationStmt"){
          const temp = stmt as IterationStmt;

          if(temp.returnExpressions.length > 0 && res.type != "end-closure"){
            return res;
          }
        }
        else if(stmt.kind == "ReturnStmt"){
          const result = evaluate((stmt as ReturnStmt), current);
          return result;
        }

      }

      

      condition = evaluate(iterStmt.iterationCondition, current);

      if(condition.type == "MemberExprVal"){
        condition = conv_memex_to_val(condition as MemberExprVal);
      }



      if((condition as BooleanVal).value){

        if(iterStmt.returnExpressions.length > 0){
          return evaluate(iterStmt.returnExpressions[0], current);
        }
        else{
          
          return res;
        }

        
      }

      if(condition.type == "null"){
        return makeError("Problem evaluating condition");
      }
      else if(errorLog.length > 0){
        return null;
      }


      iterations ++;  


      while(!(condition as BooleanVal).value){

        closures = [new Environment(scpe)];
        const current = closures[closures.length - 1];

        for(const stmt of iterStmt.body){



          res = evaluate(stmt, current);


          if(stmt.kind == "ErrorExpr"){
            return MK_NULL();
          }
          if(stmt.kind == "SelectionStmtDeclaration" && (stmt as SelectionStmtDeclaration).returns){

            console.log("Supposed return expressions: " + JSON.stringify((stmt as SelectionStmtDeclaration).returns.length));

            if(res.type != "null" && (stmt as SelectionStmtDeclaration).returns.length > 0 && res.type != "end-closure"){
              
              console.log("Returning from an if statement :(")
              return res;
            }
            else{
              console.log("I don't know what condition this is but it certainly isn't the right one...");
            }
          }

          else if(res.type != "null" && stmt.kind == "IterationStmt"){
            const temp = stmt as IterationStmt;

            if(temp.returnExpressions.length > 0 && res.type != "end-closure"){
              return res;
            }
          }
          else if(stmt.kind == "ReturnStmt"){
            const result = evaluate((stmt as ReturnStmt), current);
            return result;
          }

        }

        

        condition = evaluate(iterStmt.iterationCondition, current);

        if(condition.type == "MemberExprVal"){
          condition = conv_memex_to_val(condition as MemberExprVal);
        }



        if((condition as BooleanVal).value){

          if(iterStmt.returnExpressions.length > 0){
            return evaluate(iterStmt.returnExpressions[0], current);
          }
          else{
            
            return res;
          }

          
        }

        if(condition.type == "null"){
          return makeError("Problem evaluating condition");
        }
        else if(errorLog.length > 0){
          return null;
        }


        iterations ++;
        if(iterations > Limit){

          throw "Exceeded safe limit. You may want to consider switching to a WHILE or FOR loop.";
        }
        
      }

      return MK_NULL();

    case "pre-condition":

      const schaufe = new Environment(env);
      let kondition : RuntimeVal = evaluate(iterStmt.iterationCondition, env);

      console.log("Iteration condition: " + JSON.stringify(kondition))


      if(kondition.type == "MemberExprVal"){
        kondition = conv_memex_to_val(kondition as MemberExprVal);
      }

      let output : RuntimeVal = {type: "end-closure"} as endClosureVal;

      let iterats = 0;

      if(!(kondition as BooleanVal).value){
        return MK_NULL()
      }


      while((kondition as BooleanVal).value){
        kondition = evaluate(iterStmt.iterationCondition, env);

        if(kondition.type == "MemberExprVal"){
          kondition = conv_memex_to_val(kondition as MemberExprVal);
        }

        if(!(kondition as BooleanVal).value){

          break;
        }

        closures = [new Environment(schaufe)];
        const current = closures[closures.length - 1];

        for(const stmt of iterStmt.body){

          output = evaluate(stmt, current);

          if(stmt.kind == "ErrorExpr"){
            return MK_NULL();
          }
          else if(stmt.kind == "SelectionStmtDeclaration"){
            if((stmt as SelectionStmtDeclaration).returns.length > 0 && output.type != "null" && output.type != "end-closure"){
              return output;
            }
          }
          else if(stmt.kind == "IterationStmt"){
            const temp = stmt as IterationStmt;

            if(temp.returnExpressions.length > 0 && output.type != "null" && output.type != "end-closure"){
              return output;
            }
          }
          else if(stmt.kind == "ReturnStmt"){
            const result = evaluate((stmt as ReturnStmt), current);
            return result;
          }


        }

        iterats++;
        if(iterats > Limit){
          throw "Exceeded iteration limit. Consider switching to a FOR or REPEAT loop.";
        }
      }

      if(iterats == 0){
          
        return MK_NULL();
      }
      else{
        
        const current = closures[closures.length - 1];

        if(iterStmt.returnExpressions.length > 0){
          return evaluate(iterStmt.returnExpressions[0], current);
        }
        else{
          return output;
        }
        
      }


    default:
      return MK_NULL(); 
  }



}

function find_global_scope(env : Environment) : Environment{

  let curEnv = env;

  while(curEnv.parent !== undefined){
    curEnv = curEnv.parent;
  }

  return curEnv;
}

export function eval_binary_expr(binop: BinaryExpr, env: Environment): RuntimeVal {
  

  console.log("Binary expression details: " + JSON.stringify(binop));

  let lhs : RuntimeVal = evaluate(binop.left, env);
  let rhs : RuntimeVal = evaluate(binop.right, env);

  console.log("Rhs type: " + JSON.stringify(rhs));

  if(lhs.type === "null" || rhs.type === "null"){
    console.log("Evaluated left side: " + JSON.stringify(lhs));
    console.log("Evaluated right side: " + JSON.stringify(rhs));
  }
  


  if(lhs.type == "MemberExprVal"){
    lhs = conv_memex_to_val(lhs as MemberExprVal);
  }

  if(rhs.type == "MemberExprVal"){
    rhs = conv_memex_to_val(rhs as MemberExprVal);
  }


  //console.log(`Details of binary expr: ${JSON.stringify(lhs)}, ${JSON.stringify(rhs)}`);


  
  /*if((lhs.type == "string" && rhs.type != "string") || (lhs.type != "string" && rhs.type == "string") || (lhs.type == "char" && rhs.type != "char") || (lhs.type != "char" && rhs.type == "char")){

    return add_any(lhs, rhs);

  }
  else */if (lhs.type == "number" && rhs.type == "number") {
    return eval_numeric_binary_expr(
      lhs as NumberVal,
      rhs as NumberVal,
      binop.operator,
    );
  }
  else if((lhs.type == "string" && rhs.type == "string") || (lhs.type == "char" && rhs.type == "char")){
    return eval_string_binary_expr(
      
      lhs = convThisToStr(lhs),
      rhs = convThisToStr(rhs),
      binop.operator
    );
  }
  else if((lhs.type == "string" && rhs.type == "char") || (rhs.type == "string" && lhs.type == "char")){
    return eval_string_binary_expr(
      
      lhs = convThisToStr(lhs),
      rhs = convThisToStr(rhs),
      binop.operator
    );
  }
  else if(lhs.type == "boolean" && rhs.type == "boolean"){
    return eval_logic_binary_expr(
      lhs as BooleanVal,
      rhs as BooleanVal,
      binop.operator
    );
  }
  else if((lhs.type == "null") && rhs.type == "boolean" && (binop.operator) == "NOT"){
    
    return eval_logic_binary_expr(
      lhs as NullVal,
      rhs as BooleanVal,
      binop.operator,
    );
  }
  else if((lhs.type != "string" && lhs.type != "char") || (rhs.type != "string" && rhs.type != "char")){


    if(binop.operator == '+' || binop.operator == '&' ){
      return makeError(`Use ',' to concantenate multiple expressions into one string`);
    }
    else{
      const types = [lhs.type, rhs.type];
      if(types.includes("string") || types.includes("string")){
        lhs = convThisToStr(lhs);
        rhs = convThisToStr(rhs);

        return eval_string_binary_expr(
          lhs as StringVal,
          rhs as StringVal,
          binop.operator,
        );
      }
      else{

        //throw "Mal binary expression: " + JSON.stringify(binop.left);

        return makeError(`Cannot use binary operator '${binop.operator}' on operands of type ${lhs.type.toUpperCase()} and ${rhs.type.toUpperCase()}`)
      }
    }




  }
  else{

    return makeError(`Cannot use operator '${binop.operator}' on operands of type ${lhs.type.toUpperCase()} and ${rhs.type.toUpperCase()}!`);
  }

}

export function eval_identifier(ident: Identifier, env: Environment): RuntimeVal {

  const val = env.lookupVar(ident.symbol);
  
  if(errorLog.length > 0){
    return MK_NULL();
  }



  return val;
}

export function eval_string_expr(str : string, env: Environment) : RuntimeVal {
  //return { type:"string" , kind: "StringLiteral", value: str } as RuntimeVal;

  if(str.length == 1){
    return {type:"char", value:str} as CharVal;
  }
  else{
    return {type: "string", kind: "StringLiteral", value: str} as StringVal;
  }
}



export function eval_assignment_expr(node : AssignmentExpr, env : Environment, permission?:boolean) : RuntimeVal {
  

  
    
  let newVal : RuntimeVal = MK_STRING("");

  if(node.value.length == 1){
    newVal = evaluate(node.value[0], env);
  }
  else{
    newVal = concantate_exprs(node.value, env);
  }

  const identifier = (node.assigne as Identifier).symbol;



  //console.log("Checkpost Y after input evaluation: " + JSON.stringify(env.lookupVar("Y")));

  if(env.constants.has(identifier)){
    return makeError(`Cannot reassign to constant '${identifier}' because it is not a variable!`);
  }
  else{
    
    if(node.assigne.kind == "MemberExpr"){
        
      const varname = ((node.assigne as MemberExpr).object as Identifier).symbol;



      console.log("Assigne as member expression: " + JSON.stringify(node.assigne));

        const memex = node.assigne as MemberExpr;

        let obj = evaluate(memex.object, env);
        const constIndex = (evaluate(memex.indexComponent, env) as NumberVal);


        const index = {
          type: "number",
          numberKind: Tokens.Integer,
          value: constIndex.value,
        } as NumberVal;

        if(obj.type == "Object"){

          if(memex.secondaryIndexComponent == undefined){


            const ob = obj as ObjectVal;

            index.value = adjust_index(ob.start, ob.elements.length, index.value);

            obj = insertAtIndex(obj, newVal, index);
            env.assignVar(varname, obj);

            return obj;

          }
          else{
            console.log("Absolute raw index component: " + JSON.stringify((evaluate(memex.indexComponent, env) as NumberVal)) + JSON.stringify((evaluate(memex.secondaryIndexComponent, env) as NumberVal)));
            
            const ob = obj as ObjectVal;


            

            const old = index.value;

            index.value = adjust_index(ob.start, ob.elements.length, old);

            if(index.value < 0 || errorLog.length > 0){
              return MK_NULL();
            }

            let ch = ob.elements[index.value];

            

            if(ch.type == "Object"){
              
 
              let sIC = 
              {
                type: "number",
                numberKind: Tokens.Integer,
                value: (evaluate(memex.secondaryIndexComponent, env) as NumberVal).value,
              } as NumberVal;
              



              const childOb = (ob.elements[index.value] as ObjectVal);


              sIC.value = adjust_index(childOb.start, childOb.elements.length, sIC.value);
              
              if(errorLog.length > 0){
                return MK_NULL();
              }

              
              const replacing = childOb.elements[sIC.value];
              
              let objType = obj.type.toUpperCase();

              if(objType === "MEMBEREXPRVAL"){
                objType = (conv_memex_to_val(obj as MemberExprVal).type).toUpperCase();
              }

              if(objType === "OBJECT"){
                objType = Tokens[(obj as ObjectVal).dataType].toUpperCase();
              }

              if(!ConfirmRaw(newVal, replacing)){
                return makeError(`Cannot assign value of data type ${newVal.type.toUpperCase()} to
                  data type ${objType}!`);
              }

              
              
              obj = insertAtIndex(obj, newVal, index, sIC);
              
              

              env.assignVar(varname, obj);

              console.log("Assigned object: " + JSON.stringify(obj));

              

              return obj;
            }
            else if(ch.type == "string"){
              const constSIC = (evaluate(memex.secondaryIndexComponent, env) as NumberVal);
              let sIC = {...constSIC};
              ch = (ch as StringVal);
              sIC.value = adjust_index(1, (ch as StringVal).value.length, sIC.value);

              if(!Confirm(newVal, Tokens.Char)){
                return makeError(`Cannot assign value of data type ${newVal.type.toUpperCase()} to data type CHAR!`);
              }

              obj = insertAtIndex(obj, newVal, index, sIC);

              env.assignVar(varname, obj);

              return obj;


            }
            else{
              return makeError("Cannot mutate data that is not a string or object literal!");
            }


          }
        }
        else if(obj.type == "string"){
          if(memex.secondaryIndexComponent !== undefined){
            return makeError("Cannot access the substring of a CHAR value!");
          }
          else{

            
            index.value = adjust_index(1, (obj as StringVal).value.length, index.value);

            if(!Confirm(newVal, Tokens.Char)){
              return makeError(`Cannot assign value of data type ${newVal.type.toUpperCase()} to data type CHAR!`);
            }

            const newStr = insertAtIndex(obj, newVal, index);

            env.assignVar(varname, newStr);

            return newStr;


          }
        }
        else{
          return makeError("Object is neither an array nor a string. It is " + JSON.stringify(memex.object));
        }
        

        


    }
    else if(node.assigne.kind == "Identifier"){

      const varname = (node.assigne as Identifier).symbol;

      const varType = env.lookupVar(varname);
      
      if(!ConfirmRaw(newVal,varType)){
        console.log("Trying to assign: " + JSON.stringify(newVal));
        console.log("To assigne: " + JSON.stringify(varType));
        console.log("")


        let newValMsg = (newVal.type == "Object") ? String(Tokens[(newVal as ObjectVal).dataType]) : String(newVal.type);
        let varValMsg = (varType.type == "Object") ? String(Tokens[(varType as ObjectVal).dataType]) : String(varType.type);
        newValMsg = newValMsg.toUpperCase();
        varValMsg = varValMsg.toUpperCase();

        return makeError(`Cannot assign value of type ${newValMsg} to variable of type ${varValMsg}!`);
      }
      else{
        

        if(varType.type == "Object" && newVal.type == "Object"){
          const varObj = varType as ObjectVal;
          const newObj = newVal as ObjectVal;

          if((varObj.elements.length != newObj.elements.length) && permission == undefined){
            return makeError(`Assigne has ${varObj.elements.length} children but assigning object literal has ${newObj.elements.length} children!`);
          }
        }
        
        const aC = auto_caster(newVal, varType);



        env.assignVar(varname,aC);
        return aC;
      }

    }
    else{
      console.log("Assignment expr: " + JSON.stringify(node));
      return makeError("Can only reassign existing identifiers, not raw expressions...");
    }

  }



}



function auto_caster(getting : RuntimeVal, expecting : RuntimeVal) : RuntimeVal {
  if(expecting.type == "number"){
    return {
      type: "number",
      numberKind: (expecting as NumberVal).numberKind,
      value: (getting as NumberVal).value,
    } as NumberVal;
  }
  else if(expecting.type == "string"){
    if(getting.type == "string"){
      return getting;
    }
    else if(getting.type == "char"){
      return {
        type: "string",
        kind: "StringLiteral",
        value: (getting as CharVal).value,
      } as StringVal;
    }
    else{
      return makeError(`Cannot assign value of type ${getting.type} to data type STRING!`);
    }
  }
  else if(expecting.type == "Object"){

    return {
        type: "Object",
        elements: (getting as ObjectVal).elements,
        start: (expecting as ObjectVal).start,
        end: (expecting as ObjectVal).end,
        dataType: (expecting as ObjectVal).dataType,

    } as ObjectVal;

  }
  else{
    return getting;
  }
}

function ConfirmRaw(getting : RuntimeVal, expecting : RuntimeVal) : boolean{

  let better = expecting;
  if(better.type == "MemberExprVal"){
    better = conv_memex_to_val(better as MemberExprVal);
  }

  if(getting.type == "Object" && expecting.type != "Object"){
    makeError(`Assigne is not an object literal! `);
    return false;
  }

  switch(better.type){
    case "Object":

      if(getting.type != "Object"){
        makeError("Assigning value is not an object literal!");
        return false;
      }
      else{
        return Confirm(getting, (better as ObjectVal).dataType);
      }

      

    case "boolean":
      return Confirm(getting, Tokens.Boolean);

    case "char":
      return Confirm(getting, Tokens.Char);

    case "number":
      return Confirm(getting, (better as NumberVal).numberKind);

    case "string":
      return Confirm(getting, Tokens.String);

    default:
      return true;
  }
}





function insertAtIndex(object : RuntimeVal, newVal : RuntimeVal, index : RuntimeVal, secondaryIndex? : RuntimeVal) : RuntimeVal{

  if(object.type == "Object"){
    if(!Confirm(newVal, (object as ObjectVal).dataType)){
      return makeError(`Value of data type ${newVal.type.toUpperCase()} cannot be assigned to object literal
        of type ${Tokens[(object as ObjectVal).dataType].toUpperCase()}!`);
    }
    else{
      if(secondaryIndex == undefined){
        let tempArr = (object as ObjectVal).elements;

        tempArr.splice((index as NumberVal).value, 1, newVal);

        let newObject = object as ObjectVal;
        newObject.elements = tempArr;

        return newObject;
      

      }
      else{

        

        let parentObject = (object as ObjectVal);
        
        let childObject = parentObject.elements[(index as NumberVal).value];

        if(childObject.type == "Object"){
          childObject = (childObject as ObjectVal);

          if(!Confirm(newVal, (childObject as ObjectVal).dataType)){
            return makeError(`Cannot assign value of data type ${newVal.type.toUpperCase()} to data type ${Tokens[(childObject as ObjectVal).dataType].toUpperCase()}!`);
          }

          (childObject as ObjectVal).elements[(secondaryIndex as NumberVal).value] = newVal;

          return parentObject;

        }
        else if(childObject.type == "string"){
          if(!Confirm(newVal, Tokens.Char)){
            return makeError(`Cannot assign value of data type ${newVal.type.toUpperCase()} to data type CHAR!`);
          }

          let str = (childObject as StringVal).value;

          const secInd = (secondaryIndex as NumberVal).value

          str = str.slice(0, secInd) + (newVal as CharVal).value + str.slice(secInd + 1);

          (childObject as StringVal).value = str;

          return parentObject;
        }
        else{
          return makeError("Detected as being whatever this is");
        }
        

      }
    }
  }
  else if(object.type == "string"){

    console.log("Object type: " + object.type);

    
    let aidVal = newVal;
    if((aidVal as StringVal).value.length == 1){
      aidVal = {type: "char", value: (aidVal as StringVal).value} as CharVal;
    }

    if(!Confirm(aidVal, Tokens.Char)){
      return makeError(`Cannot assign value of data type ${aidVal.type.toUpperCase()} to data type CHAR!`);

    }
    else{

      if(secondaryIndex !== undefined){
        return makeError("Cannot access the substring of data type CHAR!");
      }
      else{

        let newStr = String((object as StringVal).value);
        const indexVal = (index as NumberVal).value;
        newStr = newStr.slice(0,indexVal) + (newVal as CharVal).value + newStr.slice(indexVal + 1);

        return {
          type: "string",
          kind: "StringLiteral",
          value: newStr,
        } as StringVal;

      }

    }
  }

}

function findlengthfromrange(start : number, end : number) : number {
  const absDiff = (end - start);

  if(absDiff < start){
    return absDiff + 1;
  }
  else{
    return absDiff;
  }
}

function fill_empty_obj(dataType : Tokens.Real | Tokens.Integer | Tokens.Boolean | Tokens.String | Tokens.Char | Tokens.Any | Tokens.Null, start : number, end : number, innerStart? : number, innerEnd? : number) : ObjectVal {

  let iterVal : RuntimeVal = MK_NULL();
  let elements : RuntimeVal[] = [];

    switch(dataType){
      case Tokens.String:
        iterVal = {
          type: "string",
          kind: "StringLiteral",
          value: " "
        } as StringVal;

        break;

      case Tokens.Char:
        iterVal = {
          type: "char",
          value: ' '
        } as CharVal;

        break;

      case Tokens.Integer:
        iterVal = {
          type: "number",
          numberKind: Tokens.Integer,
          value: 0
        } as NumberVal;

        break;

      case Tokens.Real:

        iterVal = {
          type: "number",
          numberKind: Tokens.Real,
          value: 0,
        } as NumberVal;

        break;

      case Tokens.Boolean:
        iterVal = {
          type: "boolean",
          value: false,
        } as BooleanVal;

        break;

      default:
        iterVal = MK_NULL();
    }

   

  const iterations = (end - start) + 1;   

  if(innerStart == undefined && innerEnd == undefined){

    for(let i = 0; i < iterations ; i++){
      elements.push(iterVal);
    }
  }
  else{
    for(let i = 0; i < iterations; i++){
      elements.push(fill_empty_obj(dataType, innerStart, innerEnd));
    }
  }  



  return {
    type: "Object",
    elements: elements,
    start: start,
    end: end,
    dataType: dataType,

  } as ObjectVal;
}


export function eval_object_expr(obj: ObjectLiteral, env: Environment): RuntimeVal {

  console.log("Object expression: " + JSON.stringify(obj));

  if(obj.declaring == "Range" && obj.elements.length == 0){


    if(obj.is2dArr){
      
      let start = evaluate(obj.start, env);
      if(start.type == "MemberExprVal"){
        start = conv_memex_to_val(start as MemberExprVal);
      }
      if(!isint((start as NumberVal).value)){
        return makeError(`Start value '${(start as NumberVal).value}' is not an integer!`);
      }

      let end = evaluate(obj.end, env);
      if(end.type == "MemberExprVal"){
        end = conv_memex_to_val(end as MemberExprVal);
      }
      if(!isint((end as NumberVal).value)){
        return makeError(`Start value '${(end as NumberVal).value}' is not an integer!`);
      }

      let innerStart = evaluate(obj.innerStart, env);
      if(innerStart.type == "MemberExprVal"){
        innerStart = conv_memex_to_val(innerStart as MemberExprVal);
      }
      if(!isint((innerStart as NumberVal).value)){
        return makeError(`Start value '${(innerStart as NumberVal).value}' is not an integer!`);
      }

      let innerEnd = evaluate(obj.innerEnd, env);
      if(innerEnd.type == "MemberExprVal"){
        innerEnd = conv_memex_to_val(innerEnd as MemberExprVal);
      }
      if(!isint((innerEnd as NumberVal).value)){
        return makeError(`End value '${(innerEnd as NumberVal).value}' is not an integer!`);
      }

      return fill_empty_obj(obj.dataType, (start as NumberVal).value, (end as NumberVal).value, (innerStart as NumberVal).value, (innerEnd as NumberVal).value);


    }
    else{

      let start = evaluate(obj.start, env);
      if(start.type == "MemberExprVal"){
        start = conv_memex_to_val(start as MemberExprVal) as NumberVal;
      }


      if(!isint((start as NumberVal).value)){
        return makeError(`Start value '${(start as NumberVal).value}' is not an integer!`);
      }

      let end = evaluate(obj.end, env);
      if(end.type == "MemberExprVal"){
        end = conv_memex_to_val(end as MemberExprVal);
      }


      if(!isint((end as NumberVal).value)){
        return makeError(`End value '${(end as NumberVal).value} is not an integer!'`);
      }

      const objVal = fill_empty_obj(obj.dataType, (start as NumberVal).value,( end as NumberVal).value)



      return objVal;

    }
  }
  else{

    let values : RuntimeVal[] = [];

    for(const expr of obj.elements){

      let evaluated = evaluate(expr, env);
      if(evaluated.type == "MemberExprVal"){
        evaluated = conv_memex_to_val(evaluated as MemberExprVal);
      }
      values.push(evaluated);
    }

    let dt : any;

    if(values[0].type == "number"){

      let isReal : boolean = false;

      for(const val of values){
        if(!isint((val as NumberVal).value)){
          isReal = true;
        }
      }

      dt = isReal ? Tokens.Real : Tokens.Integer;
    }
    else if(values[0].type == "string" || values[0].type == "char"){


      let isString : boolean = false;

      for(const val of values){
        if((val as StringVal).value.length != 1){
          isString = true;
        }
      }

      

      dt = isString ? Tokens.String : Tokens.Char;
    }

    else{

      dt = conv_runtimeval_dt(values[0]);
    }

    for(const val of values){
      if(!Confirm(val, dt)){
        return makeError("Item(s) in object literal does not match type! Type was " + Tokens[dt]);;
      }
    }

    return {
      type: "Object",
      elements: values,
      start: 1,
      end: values.length,
      dataType: dt,
    } as ObjectVal;

  }
  
  
}

function conv_runtimeval_dt(r : RuntimeVal) : Tokens.String | Tokens.Char | Tokens.Integer | Tokens.Real | Tokens.Boolean | Tokens.Any | Tokens.Null{

  switch(r.type){
    case "MemberExprVal":
      const n = conv_memex_to_val(r as MemberExprVal);
      return(conv_runtimeval_dt(n));

    case "Object":
      return (r as ObjectVal).dataType;

    case "boolean":
      return Tokens.Boolean

    case "char":
      return Tokens.Char

    case "string":
      return Tokens.String

    case "number":
      return (r as NumberVal).numberKind;

    default:
      return Tokens.Null;
  }
}

export function eval_member_expr(node : MemberExpr, env : Environment) : RuntimeVal {

  

  if(node.secondaryIndexComponent === undefined){



    const evaluatedParent = evaluate(node.object, env);

    if(evaluatedParent.type == "Object"){
      const evPar = evaluatedParent as ObjectVal;

      let index = (evaluate(node.indexComponent, env) as NumberVal).value;
      if(!isint(index)){
        return makeError(`Index ${index} is not an integer!`);
      }

      index = adjust_index(evPar.start, evPar.elements.length, index);
      if(errorLog.length > 0){
        return MK_NULL();
      }
      return evPar.elements[index];
    }
    else if(evaluatedParent.type == "string"){

      const evPar = evaluatedParent as StringVal;

      let index = (evaluate(node.indexComponent, env) as NumberVal).value;
      index = adjust_index(1, evPar.value.length, index);
      if(errorLog.length > 0){
        return MK_NULL();
      }

      const char = {
        type: "char",
        value: evPar.value[index]
      } as CharVal;

      return char;
    }
    else if(evaluatedParent.type == "function"){
      return makeError(JSON.stringify(evaluatedParent));
    }
    else{
      console.log("Parent object was: " + JSON.stringify(evaluatedParent) + " and member expression was " + JSON.stringify(node));

      return makeError("Parent object is neither a string literal or object literal");
    }

  }
  else{
    console.log("Evaluating member expression: " + JSON.stringify(evaluate(node.secondaryIndexComponent,env)));
    const temp = {
      kind: "MemberExpr",
      object: node.object,
      indexComponent: node.indexComponent
    } as MemberExpr;

    const parentObj = eval_member_expr(temp, env);

    console.log("Parent object: " + JSON.stringify(parentObj));

    if(parentObj.type == "Object"){
      console.log("Evaluated secondary: " + JSON.stringify(evaluate(node.secondaryIndexComponent, env)));

      

      let index = (evaluate(node.secondaryIndexComponent, env) as NumberVal).value;

      if(index == 0){
        console.log("Zerod component: " + JSON.stringify(node.secondaryIndexComponent));
      }


      console.log("Raw index: " + JSON.stringify(index));

      if(!isint(index)){
        return makeError(`Index ${index} is not an integer!`);
      }

      console.log("Adjusting details: " + JSON.stringify((parentObj as ObjectVal).start) + " and " + JSON.stringify((parentObj as ObjectVal).elements.length) + " and " + JSON.stringify(index));

      index = adjust_index((parentObj as ObjectVal).start, (parentObj as ObjectVal).elements.length,index);
      if(errorLog.length > 0){
        return MK_NULL();
      }

      const member = (parentObj as ObjectVal).elements[index];

      console.log("Evaluated member expression: " + JSON.stringify(index));

      return member;
    }
    else if(parentObj.type == "string"){
      let index = (evaluate(node.secondaryIndexComponent, env) as NumberVal).value;

      index = adjust_index(1, (parentObj as StringVal).value.length, index);

      return {
        type: "char",
        value: String((parentObj as StringVal).value[index])
      } as CharVal;
    }
    else{
      return makeError("Parent object is neither string literal nor object literal!");
    }
  }
}

export function eval_char_string(expr : CharString, env : Environment) : RuntimeVal{

  return {
    type: "char",
    value: String(expr.text),
  } as CharVal;

}

export function adjust_index(start:number, len:number, i:number) : number{

  const newIndex = i - start;
  const end = (start + len) - 1;

  if(i < start || newIndex > end){


    //throw new Error("Index out of range because i was " + i + " And start was: " + start + " and length was: " + len);
    makeError("Index out of range because i was " + i + " And start was: " + start + " and length was: " + len);
    
  }

  return newIndex;



  
}

function unwrap(str) : string {
  // Check if string is at least 2 chars and starts/ends with the same quote type
  if (
    typeof str === "string" &&
    str.length >= 2 &&
    ((str.startsWith('"') && str.endsWith('"')) ||
     (str.startsWith("'") && str.endsWith("'")))
  ) {
    return str.slice(1, -1); // Remove first and last char
  }
  return str;
}

function add_any(left : RuntimeVal, right : RuntimeVal) : StringVal{

  let l = convThisToStr(left);
  l.value = unwrap(l.value);

  let r = convThisToStr(right);
  r.value = unwrap(r.value);
  return {kind: "StringLiteral", type: "string", value: l.value + r.value} as StringVal;

}

function Confirm(runtimeval : RuntimeVal, returnType : Tokens.Char | Tokens.String | Tokens.Integer | Tokens.Real | Tokens.Boolean | Tokens.Any | Tokens.Null) : boolean{
  let evaluatedType : Tokens.Char | Tokens.String | Tokens.Integer | Tokens.Real | Tokens.Boolean | Tokens.Any | Tokens.Null;
  console.log("Runtime val: " + JSON.stringify(runtimeval));
  switch(runtimeval.type){
    case "MemberExprVal":
      const memex = conv_memex_to_val(runtimeval as MemberExprVal);
      return Confirm(memex, returnType);


    case "Object":
      evaluatedType = (runtimeval as ObjectVal).dataType;
      break;

    case "boolean":
      evaluatedType = Tokens.Boolean
      break;

    case "string":
      const stringText = (runtimeval as StringVal).value;

      if(stringText.length == 1){
        evaluatedType = Tokens.Char;
      }
      else{
        evaluatedType = Tokens.String;
      }
      break;

    case "char":
      evaluatedType = Tokens.Char;
      break;

    case "number":
      const num = (runtimeval as NumberVal).value

      if(isint(num)){
        evaluatedType = Tokens.Integer;
      }
      else{
        evaluatedType = Tokens.Real;
      }
      break;

    default:
      evaluatedType = Tokens.Null;


  }

  console.log("Evaluated type: " + Tokens[evaluatedType]);



  if(evaluatedType !== returnType){
    if(returnType == Tokens.Real && evaluatedType == Tokens.Integer){

      return true;
    }
    else if(returnType == Tokens.String && evaluatedType == Tokens.Char){
      return true;
    }
    else{
      if(returnType == Tokens.Any){
        return true;
      }
      else{
        makeError(`Values is not of type ${Tokens[returnType].toUpperCase()}!`);
        return false;
      }
      
    }
  }
  else{
    return true
  }

}

function maxeval(expr : Expr, env : Environment) : RuntimeVal {
  const temp = evaluate(expr, env);

  if(temp.type == "MemberExprVal"){
    return conv_memex_to_val(temp as MemberExprVal);
  }
  else{
    return temp;
  }
}

export function eval_call_expr(expr : CallExpr, env : Environment): RuntimeVal {
  


  const args = expr.args.map((arg) => maxeval(arg, env));
  const fn = evaluate(expr.caller, env);
  
  if(errorLog.length > 0){
    return MK_NULL();
  }

  

  if(fn.type == "native-fn"){

    const nativeFnValue = fn as NativeFnValue;

    

    const result = nativeFnValue.call(args, env);
	  return result;
  }
  else if(fn.type = "function"){
    
    const func = fn as FunctionValue;
    const funcProcComponent = eval_identifier(expr.caller as Identifier, env) as FunctionValue ;


    if(expr.wasCallKeywordUsed && !funcProcComponent.isProcedure){
      return makeError("Remove 'CALL' keyword");
    }

    if(!expr.wasCallKeywordUsed && funcProcComponent.isProcedure){
      return makeError("Must use 'CALL' keyword when calling procedures!") ;
    }
    
    
    const scope = new Environment(func.declarationEnv);
    console.log("Declaration environment: ");


    if(func.parameters.size != args.length){
      return makeError(`Expected ${func.parameters.size} arguments, but got ${args.length}`);
    }

    if(func.parameters !== null){
      if(func.parameters.size > 0){

        console.log("Function arguments: " + JSON.stringify(args));

        for(let i = 0; i < args.length; i++){
          let arg = args[i];
          const parameter = Array.from(func.parameters.entries())[i];

          if(arg.type == "MemberExprVal"){
            arg = conv_memex_to_val(arg as MemberExprVal);
          }

          let paramType : RuntimeVal;
          
          if(parameter[1].kind == "ObjectLiteral"){

            if(arg.type != "Object"){
              return makeError("Expecting argument to be object literal!");
            }

            if(!Confirm(arg, (parameter[1] as ObjectLiteral).dataType)){
              return makeError(`Object literal is not of type ${Tokens[(parameter[1] as ObjectLiteral).dataType].toUpperCase()}`)
            }

            paramType = {
              type: "Object",
              elements: (arg as ObjectVal).elements,
              start: (arg as ObjectVal).start,
              end: (arg as ObjectVal).end,
              dataType: (parameter[1] as ObjectLiteral).dataType,
            } as ObjectVal;

          } 
          else{
            paramType = evaluate(parameter[1], scope);
            console.log("Apparently param type is: " + JSON.stringify(parameter[1]));
          }
          

          if(!ConfirmRaw(arg, paramType)){

            let paramTypeMsg = String(paramType.type);

            if(paramTypeMsg == "number"){
              paramTypeMsg = Tokens[(paramType as NumberVal).numberKind];
            }
            else if(paramTypeMsg == "Object"){
              paramTypeMsg = Tokens[(paramType as ObjectVal).dataType];
            }

            paramTypeMsg = paramTypeMsg.toUpperCase();

            if(errorLog.length == 0){
              return makeError(`Argument '${JSON.stringify((arg as StringVal).value)}' is not of type ${paramTypeMsg}`);
            }
            else{
              return MK_NULL();
            }
            
          }


          
        }

        for (let i = 0; i < func.parameters.size; i++){
      
          const varname = Array.from(func.parameters.keys())[i];
          scope.declareVar(varname, args[i], false);
        }

        console.log("Scope variables: " + JSON.stringify(Array.from(scope.variables.entries())));
      }
    }

    

    

    let result : RuntimeVal = MK_NULL();
    


    for(const stmt of func.body){

      console.log("Stmt kind: " + stmt.kind);
      
      if(stmt.kind == "SelectionStmtDeclaration"){

        result = evaluate(stmt, scope);

        const selec_bod = Array.from((stmt as SelectionStmtDeclaration).body);

        console.log("Body of selection statement within function: " + JSON.stringify(selec_bod[1]));

        if(result){
          if(result.type !== "null" &&  (stmt as SelectionStmtDeclaration).returns.length > 0 && result.type != "end-closure"){


            const returnType = evaluate(func.returnType, scope);

            if(!func.isProcedure){


              if(returnType.type == "Object"){

                if(!confirmForReturning(result, func.returnType, scope)){
                  return MK_NULL();
                }
                else{
                  return result;
                }

              }
              else{

                const rt = conv_runtimeval_dt(returnType);

                if(Confirm(result, rt)){
                  console.log("Selection statement fully evaluated!");
                  return result;
                }
                else{
                  return makeError(`Value is not of type ${Tokens[rt]} because
                    it is of type ${JSON.stringify(result)}!`);
                }

              }



              
            }
            else{
              return makeError("Procedures may not return a value!");
            }
          }
        }

        

        
      }
      else if(stmt.kind == "IterationStmt"){



        result = evaluate(stmt, scope);
        const temp = stmt as IterationStmt;

        console.log("Result of selection statement: " + JSON.stringify(result));

        if(result){
          
          if(result.type !== "null" && temp.returnExpressions.length > 0 && result.type != "end-closure"){
          
            
            if(!func.isProcedure){

              if(!confirmForReturning(result, func.returnType, scope)){
                return MK_NULL();
              }
              else{
                return result;
              }
            }
            else{
              return makeError("Procedures may not return a value!");
            }
          }
        }



      }
      else if(stmt.kind == "ReturnStmt"){

        if(func.isProcedure){
          return makeError("Procedures may not return a value!");
        }
        else{

          result = eval_return_stmt(stmt as ReturnStmt, scope);


          if(!confirmForReturning(result, func.returnType, scope)){

            return MK_NULL();
          }
          else{

            
            return result;
          }


          
        }


      }
      else{
        
        result = evaluate(stmt, scope);
        
      }


    }

    
      if(!func.isProcedure){
        for(const expr of func.returnExpressions){
          result = evaluate(expr, scope);

          if(result){
            if(result.type == "MemberExprVal"){
              result = conv_memex_to_val(result as MemberExprVal);
            }
          }
          

          const returnType = conv_runtimeval_dt(evaluate(func.returnType, scope));

          const returnToken = conv_dt_runtimeval(returnType);
          result = auto_caster(result, returnToken);


          if(!func.isProcedure && !kindMatchesToken(result, returnType,env)){
             makeError( `Return type is not ${result.type},
            !`);
          }
        }
      }


    return result;
    
  }
  else{
    return makeError(`Function does not exist!`);
  }



}


function confirmForReturning(getting:RuntimeVal, expecting:Expr, env : Environment) : boolean {

  if(expecting.kind == "ObjectLiteral"){

    if(getting.type != "Object"){
      makeError("Value returned is not an object literal!");
    }

    const r = (expecting as ObjectLiteral).dataType;

    console.log("Evaluated result: " + Tokens[(getting as ObjectVal).dataType]);
    console.log("Evaluated result: type: " + JSON.stringify(Tokens[r]));
    
    if(Confirm(getting, r)){
      return true;
    }
    else{
      makeError(`Returned value is not of type ${Tokens[r].toUpperCase()}`);
      return false;
    }


  }
  else{
    const rtv = evaluate(expecting, env);

    if(ConfirmRaw(getting, rtv)){
      return true;
    }
    else{
      return false;
    }
  }

}

function conv_dt_runtimeval(dt : Tokens.Integer | Tokens.Real | Tokens.Boolean | Tokens.Char | Tokens.String | Tokens.Any | Tokens.Null) : RuntimeVal {

  switch(dt){
    case Tokens.Integer:
      return {type: "number", numberKind: dt, value: 0} as NumberVal;

    case Tokens.Real:
      return {type: "number", numberKind: dt, value: 0} as NumberVal;

    case Tokens.String:
      return {type: "string", kind: "StringLiteral", value: " "} as StringVal;

    case Tokens.Char:
      return {type: "char", value: ' '} as CharVal;

    case Tokens.Boolean:
      return {type: "boolean", value: false} as BooleanVal;

    default:
      return MK_NULL();
  }

}


function assess_dataType_fromstring(str : string) 
: Tokens.Any
  | Tokens.Integer
  | Tokens.Real
  | Tokens.String
  | Tokens.Char
  | Tokens.Boolean
  | Tokens.Null{

    if(str.startsWith('"') && str.endsWith('"')){
      return Tokens.String;
    }
    else if(str.startsWith("'") && str.endsWith("'")){
      return Tokens.Char;
    }
    else if(isNumeric(str)){

      if(isint(Number(str))){
        return Tokens.Integer;
      }
      else{
        return Tokens.Real;
      }
    }
    else if(str == "TRUE" || str == "FALSE"){
      return Tokens.Boolean;
    }
    else if(str == "NULL"){
      return Tokens.Null;
    }
    else{
      return Tokens.Any;
    }

}



function isNumeric(str: string): boolean {
  return !isNaN(Number(str)) && str.trim() !== '';
}

function kindMatchesToken(val : RuntimeVal, tk :
  Tokens.Integer
  | Tokens.Real
  | Tokens.Boolean
  | Tokens.String
  | Tokens.Char
  | Tokens.Any
  | Tokens.Null, env : Environment
) : boolean{

  
  
  const kind = val.type;

  switch(kind){

    case "string":
      if(tk == Tokens.String){
        return true;
      }
      else{
        return false
      }


    case "char":
      if(tk == Tokens.Char){
        return true;
      }
      else{
        return false;
      }


    case "number":
      const numKind = (val as NumberVal).numberKind;

      if(tk == numKind){
        return true
      }
      else{
        return false
      }


    case "boolean":
      if(tk == Tokens.Boolean){
        return true
      }
      else{
        return false
      }


    case "null":
      if(tk == Tokens.Null){
        return true
      }
      else{
        return false
      }


    case "Object":
      if(tk == (val as ObjectVal).dataType){
        return true
      }
      else{
        return false
      }

    case "MemberExprVal":
      const temp = conv_memex_to_val(val as MemberExprVal);

      return kindMatchesToken(temp, tk, env);

    case "function":

      const rtv = evaluate((val as FunctionValue).returnType, env);
      const rtk = conv_runtimeval_dt(rtv);

      if(tk == rtk){
        return true;
      }
      else{
        return false;
      }

    case "native-fn":
      console.log("Native function return types cannot be evaluated yet :(");
      return true;
      

    default:
      return false;

  }
}

export function eval_unary_expr(unaryExpr : UnaryExpr, env : Environment) : RuntimeVal {

  let val = evaluate(unaryExpr.right, env);
  if(val.type == "MemberExprVal"){
    val = conv_memex_to_val(val as MemberExprVal);
  }



  if(unaryExpr.operator == '+'){
    return val as NumberVal;
  }
  else if(unaryExpr.operator == '-'){
    return {
      type: "number",
      numberKind: (val as NumberVal).numberKind,
      value: -(val as NumberVal).value,
    } as NumberVal;
  }
  else{
    makeError("Unrecognised unary operator!");
  }
}


function stringifyPlus(str : any, rTVT : RuntimeVal) : string{
  let toUse = JSON.stringify(str);

  if(toUse.startsWith('"') && toUse.endsWith('"') && rTVT.type !== "string"){
    toUse = toUse.slice(1,-1);
  }
  else if(toUse.startsWith("'") && toUse.endsWith("'") && rTVT.type !== "char"){
    toUse = toUse.slice(1,-1);
  }
  else if(toUse.startsWith['['] && toUse.endsWith(']') && rTVT.type !== "Object"){
    toUse = toUse.slice(1,-1);
  }
  else if(toUse.startsWith('"') && toUse.endsWith('"') && rTVT.type == "Object"){

    toUse = toUse.slice(1,-1);
  }

  return toUse;
}

function CustomWrap(symbol : string, word : string){
  if(!(word.startsWith(symbol) && word.endsWith(symbol))){
    return symbol + word + symbol;
  }
  else{
    return word
  }
}

function convThisToStr(val : RuntimeVal) : StringVal{
  let value : string = "";

  if(val === undefined){
    console.log("Val was: " + JSON.stringify(val));
  }

  switch(val.type){
    case "string":

      value = (val as StringVal).value;

      

      break;

    case "MemberExprVal":

      let memex : RuntimeVal = val;
      
      if(memex.type == "MemberExprVal"){
        memex = conv_memex_to_val(memex as MemberExprVal);
      }



      return convThisToStr(memex);
       


    case "Object":
      value = '[';
      const obj = val as ObjectVal;
      console.log("Object val: " + JSON.stringify(obj));

      for(const elm of obj.elements){

        let toAdd = stringifyPlus(convThisToStr(elm).value, elm);
        if(elm.type == "Object" && toAdd.startsWith('"') && toAdd.endsWith('"')){
          toAdd = toAdd.slice(1,-1);
        }

        console.log("To add: " + toAdd);
        value += toAdd;

        value += ","
      }

      value = value.substring(0, value.length - 1);

      value += ']'
      
      break;

    case "boolean":
      value = String((val as BooleanVal).value).toUpperCase();
      break;

    case "char":
      value = String((val as CharVal).value);
      value = CustomWrap("'", value);
      break;

    case "number":
      value = String((val as NumberVal).value);
      break;

    default:
      value = JSON.stringify(val);
  }


  const new_stringval =  MK_STRING(value);

  if(new_stringval == undefined){
    console.log("New string val was undefined! Value was: " + value);
  }

  return new_stringval;
}