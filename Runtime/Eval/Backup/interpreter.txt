import {  endClosureVal, NullVal, NumberVal, RuntimeVal, SelectionStmt } from "./Value.js";
import {
  AssignmentExpr,
  BinaryExpr,
  Expr,
  Identifier,
  NumericLiteral,
  Program,
  Stmt,
  StringLiteral,
  VarDeclaration,
  ObjectLiteral,
  MemberExpr,
  CallExpr,
  FunctionDeclaration,
  SelectionStmtDeclaration,
  IterationStmt,
  OutputExpr,
  inputExpr,
  FileExpr,
  FileUse,
  UnaryExpr,
  ReturnStmt,
  CharString,

} from "../Frontend/AST.js";
import Environment from "./Environment.js";
import {eval_return_stmt ,eval_char_string, eval_unary_expr, eval_input_expr, eval_output_expr, eval_iteration_Stmt , eval_call_expr ,eval_member_expr, eval_object_expr, eval_identifier, eval_binary_expr, eval_string_expr, eval_assignment_expr, eval_selectionStmt_expr, eval_fileUse_expr } from "./Eval/Expressions.js";
import {eval_file_statement, eval_fn_declaration, eval_program, eval_var_declaration } from "./Eval/Statements.js";
import { Tokens } from "../Frontend/Lexer.js";
import { errorLog } from "../Main.js";

/**
 * Evaulate pure numeric operations with binary operators.
 */


export function evaluate(astNode: Stmt, env: Environment): RuntimeVal {
  if(astNode == null || errorLog.length > 0){

    return {
      type: "null",
      value: null,
    } as NullVal;
  }
  else{
    console.log("Ideally you should not be seeing this...");
    switch (astNode.kind) {
      
      case "NumericLiteral":
        let NK = (astNode as NumericLiteral).numberKind;
        const value = ((astNode as NumericLiteral).value);
        if(NK == undefined){
          if(isInt(value)){
            NK = Tokens.Integer;
          }
          else{
            NK = Tokens.Real;
          }
        }
        return {
          value: value,
          numberKind: NK,
          type: "number",
        } as NumberVal;

      case "Identifier":
        return eval_identifier(astNode as Identifier, env);

      case "AssignmentExpr":

        console.log("Maybe it's the way you're dressed?")

        return eval_assignment_expr(astNode as AssignmentExpr, env);

      case "BinaryExpr":
        console.log("Evaluating binary expression");
        return eval_binary_expr(astNode as BinaryExpr, env);

      case "StringLiteral":
        const textComponentHolder = astNode as StringLiteral;
        return eval_string_expr(textComponentHolder.text, env);  

      case "Program":
        const program = astNode as Program;
        const err = {kind: "ErrorExpr"} as Expr;

        if(program.body.length == 1 && program.body[0] == err){

          return {
            type: "null",
            value: null,
          } as NullVal;
        }
        else{
          return eval_program(astNode as Program, env);
        }
        
      case "CharString":
        return eval_char_string(astNode as CharString, env);

      case "VarDeclaration":
        
        return eval_var_declaration(astNode as VarDeclaration, env);

      case "FunctionDeclaration":
        return eval_fn_declaration(astNode as FunctionDeclaration, env);

      case "ObjectLiteral":
        const astObjectLiteral = astNode as ObjectLiteral;
        return eval_object_expr(
          astObjectLiteral, 
          env, );

      case "CallExpr":
        console.log("I see this as a call expression!");
        return eval_call_expr(astNode as CallExpr, env);

      case "MemberExpr":
        

        return eval_member_expr(astNode as MemberExpr, env);

      case "SelectionStmtDeclaration":
        return eval_selectionStmt_expr(astNode as SelectionStmtDeclaration, env);

      case "IterationStmt":
        return eval_iteration_Stmt(astNode as IterationStmt, env);

      case "OutputExpr":
        return eval_output_expr(astNode as OutputExpr, env);

      case "InputExpr":
        return eval_input_expr(astNode as inputExpr, env);

      case "FileExpr":
        return eval_file_statement(astNode as FileExpr, env);

      case "FileUse":

        //throw new Error("Problem detected?");

        return eval_fileUse_expr(astNode as FileUse, env);

      case "UnaryExpr":
        return eval_unary_expr(astNode as UnaryExpr, env);

      case "EndClosureExpr":
        return {
          type: "end-closure"
        } as endClosureVal;

      case "NullLiteral":
          return {
            type: "null",
            value: null,
          } as NullVal;

      case "ReturnStmt":
        const returnStmt = astNode as ReturnStmt;

        return eval_return_stmt(returnStmt, env);

      case "ErrorExpr":

          throw "Safety first :D";
      default:
        console.log("AST node kind: " + astNode.kind);
        throw "AST node not yet setup for interpretation";
        
    }
  }

    

}

function isInt(value) {
  const num = Number(value);
  return !isNaN(num) && Number.isInteger(num);
}
